<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>QUIC协议介绍 | Hexo</title>
  <meta name="keywords" content=" quic , udp ">
  <meta name="description" content="QUIC协议介绍 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick">
<meta property="og:type" content="article">
<meta property="og:title" content="Hello World">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;10&#x2F;26&#x2F;hello-world&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-10-26T09:25:41.031Z">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>Blitz</span>
</div>

<div class="icon">
    
        
        <a title="rss" href="/atom.xml" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-rss"></use>
                </svg>
            
        </a>
        
    
        
        <a title="github" href="https://github.com/WhatDream" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
    
        
    
        
        <a title="email" href="mailto:1522515386@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1522515386&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(6)</small></div></li>
    
        
            
            <li><div data-rel="锁">锁<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="网络">网络<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="大前端">大前端<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="6">
<input type="hidden" id="yelog_site_word_count" value="15.1k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="Search..." autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color2">Idempotency</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color1">mysql</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">lock</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">quic</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">udp</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color5">node</a>
    </li>
    
    <li class="article-tag-list-item">
        <a href="javascript:" class="color4">spinlock</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <nav id="title-list-nav">
        
        <a  class=""
           href="/2019/10/25/First-Post-For-Idempotency/"
           data-tag="Idempotency"
           data-author="" >
            <span class="post-title" title="First Post For Idempotency">First Post For Idempotency</span>
            <span class="post-date" title="2019-10-25 18:33:37">2019/10/25</span>
        </a>
        
        <a  class="锁 "
           href="/2019/10/26/Mysql%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/"
           data-tag="mysql,lock"
           data-author="" >
            <span class="post-title" title="Mysql悲观锁与乐观锁">Mysql悲观锁与乐观锁</span>
            <span class="post-date" title="2019-10-26 11:16:37">2019/10/26</span>
        </a>
        
        <a  class="网络 "
           href="/2019/10/26/QUIC%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/"
           data-tag="quic,udp"
           data-author="" >
            <span class="post-title" title="QUIC协议介绍">QUIC协议介绍</span>
            <span class="post-date" title="2019-10-26 11:16:37">2019/10/26</span>
        </a>
        
        <a  class=""
           href="/2019/10/26/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2019-10-26 17:25:41">2019/10/26</span>
        </a>
        
        <a  class="大前端 "
           href="/2017/03/16/npm/"
           data-tag="node"
           data-author="" >
            <span class="post-title" title="npm使用介绍">npm使用介绍</span>
            <span class="post-date" title="2017-03-16 20:09:48">2017/03/16</span>
        </a>
        
        <a  class="锁 "
           href="/2019/10/26/%E8%87%AA%E6%97%8B%E9%94%81/"
           data-tag="spinlock"
           data-author="" >
            <span class="post-title" title="自旋锁">自旋锁</span>
            <span class="post-date" title="2019-10-26 11:16:37">2019/10/26</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-QUIC协议介绍" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">QUIC协议介绍</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a href="javascript:" data-rel="网络">网络</a>
            
        </span>
        
        
        <span class="tag">
            
            <a href="javascript:" class="color5">quic</a>
            
            <a href="javascript:" class="color4">udp</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2019-10-26 17:25:41'>2019-10-26 11:16</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:9.4k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC协议介绍"><span class="toc-text">QUIC协议介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC的由来"><span class="toc-text">QUIC的由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC简介"><span class="toc-text">QUIC简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QUIC优势"><span class="toc-text">QUIC优势</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#减少了-TCP-三次握手及-TLS-握手时间"><span class="toc-text">减少了 TCP 三次握手及 TLS 握手时间</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#时间延迟"><span class="toc-text">时间延迟</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#改进的拥塞控制"><span class="toc-text">改进的拥塞控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#避免队头阻塞的多路复用"><span class="toc-text">避免队头阻塞的多路复用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#连接迁移"><span class="toc-text">连接迁移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#前向冗余纠错"><span class="toc-text">前向冗余纠错</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#总是加密"><span class="toc-text">总是加密</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双级别流量控制"><span class="toc-text">双级别流量控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现QUIC"><span class="toc-text">实现QUIC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Chromium"><span class="toc-text">1. Chromium</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-proto-quic"><span class="toc-text">2. proto-quic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-goquic"><span class="toc-text">3. goquic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-quic-go"><span class="toc-text">4. quic-go</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能测试"><span class="toc-text">性能测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2017年海外部署测试"><span class="toc-text">2017年海外部署测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#QQ页面接入测试"><span class="toc-text">QQ页面接入测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能优化"><span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化1：提升-0RTT-成功率"><span class="toc-text">性能优化1：提升 0RTT 成功率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化2：连接迁移-Connection-Migration-的实现"><span class="toc-text">性能优化2：连接迁移 (Connection Migration) 的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化3：动态的流量控制和拥塞控制"><span class="toc-text">性能优化3：动态的流量控制和拥塞控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包类型和格式"><span class="toc-text">包类型和格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QUIC公共包头"><span class="toc-text">QUIC公共包头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊包"><span class="toc-text">特殊包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#版本协商包"><span class="toc-text">版本协商包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#公共复位包"><span class="toc-text">公共复位包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#普通包"><span class="toc-text">普通包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#帧包"><span class="toc-text">帧包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC连接生命周期"><span class="toc-text">QUIC连接生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#连接建立"><span class="toc-text">连接建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据传输"><span class="toc-text">数据传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QUIC流的生命"><span class="toc-text">QUIC流的生命</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#帧类型和格式"><span class="toc-text">帧类型和格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#STREAM帧"><span class="toc-text">STREAM帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ACK帧"><span class="toc-text">ACK帧</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#段偏移"><span class="toc-text">段偏移</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STOP-WAITING-帧"><span class="toc-text">STOP_WAITING 帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WINDOW-UPDATE-帧"><span class="toc-text">WINDOW_UPDATE 帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BLOCKED-帧"><span class="toc-text">BLOCKED 帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RST-STREAM-帧"><span class="toc-text">RST_STREAM 帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CONNECTION-CLOSE-帧"><span class="toc-text">CONNECTION_CLOSE 帧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC现状"><span class="toc-text">QUIC现状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><h2>目录</h2><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC协议介绍"><span class="toc-text">QUIC协议介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC的由来"><span class="toc-text">QUIC的由来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC简介"><span class="toc-text">QUIC简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QUIC优势"><span class="toc-text">QUIC优势</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#减少了-TCP-三次握手及-TLS-握手时间"><span class="toc-text">减少了 TCP 三次握手及 TLS 握手时间</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#时间延迟"><span class="toc-text">时间延迟</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#改进的拥塞控制"><span class="toc-text">改进的拥塞控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#避免队头阻塞的多路复用"><span class="toc-text">避免队头阻塞的多路复用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#连接迁移"><span class="toc-text">连接迁移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#前向冗余纠错"><span class="toc-text">前向冗余纠错</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#总是加密"><span class="toc-text">总是加密</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双级别流量控制"><span class="toc-text">双级别流量控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现QUIC"><span class="toc-text">实现QUIC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Chromium"><span class="toc-text">1. Chromium</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-proto-quic"><span class="toc-text">2. proto-quic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-goquic"><span class="toc-text">3. goquic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-quic-go"><span class="toc-text">4. quic-go</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能测试"><span class="toc-text">性能测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2017年海外部署测试"><span class="toc-text">2017年海外部署测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#QQ页面接入测试"><span class="toc-text">QQ页面接入测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能优化"><span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化1：提升-0RTT-成功率"><span class="toc-text">性能优化1：提升 0RTT 成功率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化2：连接迁移-Connection-Migration-的实现"><span class="toc-text">性能优化2：连接迁移 (Connection Migration) 的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化3：动态的流量控制和拥塞控制"><span class="toc-text">性能优化3：动态的流量控制和拥塞控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包类型和格式"><span class="toc-text">包类型和格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QUIC公共包头"><span class="toc-text">QUIC公共包头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊包"><span class="toc-text">特殊包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#版本协商包"><span class="toc-text">版本协商包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#公共复位包"><span class="toc-text">公共复位包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#普通包"><span class="toc-text">普通包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#帧包"><span class="toc-text">帧包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC连接生命周期"><span class="toc-text">QUIC连接生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#连接建立"><span class="toc-text">连接建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据传输"><span class="toc-text">数据传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QUIC流的生命"><span class="toc-text">QUIC流的生命</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#帧类型和格式"><span class="toc-text">帧类型和格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#STREAM帧"><span class="toc-text">STREAM帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ACK帧"><span class="toc-text">ACK帧</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#段偏移"><span class="toc-text">段偏移</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STOP-WAITING-帧"><span class="toc-text">STOP_WAITING 帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WINDOW-UPDATE-帧"><span class="toc-text">WINDOW_UPDATE 帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BLOCKED-帧"><span class="toc-text">BLOCKED 帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RST-STREAM-帧"><span class="toc-text">RST_STREAM 帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CONNECTION-CLOSE-帧"><span class="toc-text">CONNECTION_CLOSE 帧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC现状"><span class="toc-text">QUIC现状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></div></p>
<h2 id="QUIC协议介绍"><a href="#QUIC协议介绍" class="headerlink" title="QUIC协议介绍"></a>QUIC协议介绍</h2><h3 id="QUIC的由来"><a href="#QUIC的由来" class="headerlink" title="QUIC的由来"></a>QUIC的由来</h3><p>HTTP/2的硬伤就是TCP，TCP连接的稳定和可靠解决了当时的网络问题，在如今网络可靠性和速度上，TCP的弊端尤为突出，而且TCP更新优化依赖系统内核更新，而且一次更新可能需要十年时间普及。</p>
<p>构建基础网络，或者更新HTTP可以一定程度上加速网络，减轻用户感知延迟，下图可以说明这个问题。</p>
<p><img src="/images/lead_to_quic.png" alt="quic"></p>
<p>日益高速高速发展的应用层和缓慢进化的网络传输层的矛盾日渐明显，Google的工程师决定抛弃TCP，转向UDP，因为UDP不需要建连，协议简单，是不稳定的乐观协议。至于保证数据可靠、防止IP攻击、加密处理等等工作放在UDP协议之上，也就是QUIC协议，升级不依赖底层系统，能实现TCP类似的功能，可定制化，而且能带来网络速度和可靠性的提升。</p>
<h3 id="QUIC简介"><a href="#QUIC简介" class="headerlink" title="QUIC简介"></a>QUIC简介</h3><p>QUIC 是 Quick UDP Internet Connections 的缩写，谷歌发明的新传输协议。与 TCP 相比，QUIC 可以减少延迟。从表面上看，QUIC 非常类似于在 UDP 上实现的 TCP + TLS + HTTP/2。由于 TCP 是在操作系统内核和中间件固件中实现的，因此对 TCP 进行重大更改几乎是不可能的。但是，由于 QUIC 建立在 UDP 之上，因此没有这种限制。QUIC 可以实现可靠传输，而且相比于 TCP，它的流控功能在用户空间而不在内核空间，那么使用者就 不受限于 CUBIC 或是 BBR，而是可以自由选择，甚至根据应用场景自由调整优化。</p>
<p>QUIC 与现有 TCP + TLS + HTTP/2 方案相比，有以下几点主要特征：</p>
<ul>
<li>基于UDP的TCP+TLS+SPDY</li>
<li>比TLS/TCP更快的网络连接，利用缓存，显著减少连接建立时间<ul>
<li>通常是0-RTT，有时是1-RTT</li>
</ul>
</li>
<li>处理包丢失上比TCP协议表现更好</li>
<li>基于流(STREAM)级别和连接(Connection)级别的流控制</li>
<li>前向纠错，减少重传</li>
<li>没有 head of line 阻塞的多路复用</li>
<li>连接平滑迁移，网络状态的变更不会影响连接断线</li>
<li>改善拥塞控制，拥塞控制从内核空间到用户空间</li>
</ul>
<p>下图可以清晰的表示QUIC在网络中的位置：</p>
<p><img src="/images/quic-archi.png" alt="quic架构"></p>
<p>QUIC 在 UDP 之上，如果想要和 TCP/IP 体系类比，那么就是上图。QUIC 可以类比 TCP/IP 中的 TLS 一层。但是功能又不完全是 TLS ，还有一部分 HTTP/2 ，下面还包括一部分 TCP 的功能，比如 拥塞控制、丢包恢复、流量控制等特性。</p>
<p>QUIC相比tls1.3在首次握手、弱网环境上都有很大的优势。</p>
<h4 id="QUIC优势"><a href="#QUIC优势" class="headerlink" title="QUIC优势"></a>QUIC优势</h4><h5 id="减少了-TCP-三次握手及-TLS-握手时间"><a href="#减少了-TCP-三次握手及-TLS-握手时间" class="headerlink" title="减少了 TCP 三次握手及 TLS 握手时间"></a>减少了 TCP 三次握手及 TLS 握手时间</h5><p>传统的TCP协议，我们需要进行3次握手，也就是1.5 RTT，才开始传输数据。而且HTTP/2的实现上大都绑定了TLS，需要确定加密版本、加密密钥等，因此TCP+TLS需要3 RTT。</p>
<p>0 RTT 的效果是因为QUIC的客户端会缓存服务器端发的令牌和证书，当有数据需要再次发送的时候，客户端可以直接使用旧的令牌和证书，这样子就实现了 0 RTT 了。对于没有缓存的情况，服务器端会直接拒绝请求，并且返回新生产的令牌和证书。 所以当令牌失效或者没有缓存的情况下，QUIC还是需要一次握手才能开始传输数据。</p>
<p><img src="/images/quic_comparion.png" alt="连接建立"></p>
<p>为了保证安全，QUIC也是加密传输数据的，所以在QUIC的建连过程中也需要双方协商出一个加密私钥。但与TLS不同，QUIC采用的加密算法仅需要一个RTT就能实现密钥交换，并且该算法也被用于目前正在草案阶段的TLS1.3协议。该就是Diffie-Hellman密钥交换算法。</p>
<p><img src="F:/weekly//images/diffie-hellman.jpg" alt="建连"></p>
<p>可以看到，客户端和服务端各自保留了自己的私钥a和b，通过交换各自的公钥B和A，以及基底G和很大的质数P，双方就能计算出相等的私钥S，这个S就是加密传输的对称密钥。<br>另外，根据离散对数的不可逆，即使拿到G,P,和质数B，也很难推导出私钥b（同理私钥a），也就保证了计算密钥的安全。<br>该过程对应到QUIC建连的过程中如下图。</p>
<p><img src="F:/weekly//images/1rtt.jpg" alt="1RTT"></p>
<ul>
<li>客户端发起Inchoate client hello</li>
<li>服务器返回Rejection，包括密钥交换算法的公钥信息，算法信息，证书信息等被放到server config中传给客户端</li>
<li>客户端发起client hello，包括客户端公钥信息</li>
</ul>
<p>此时，双方各自计算出了对称密钥。QUIC的1RTT建连过程结束，平均只耗时100ms以内。</p>
<p>后续发起连接的过程中，一旦客户端缓存或持久化了server config，就可以复用并结合本地生成的私钥进行加密数据传输了，不需要再次握手，从而实现0RTT建立连接。</p>
<h6 id="时间延迟"><a href="#时间延迟" class="headerlink" title="时间延迟"></a>时间延迟</h6><ul>
<li>0-RTT<ul>
<li>超过50%的时间延迟提升(大概在50%和95%之间)</li>
</ul>
</li>
<li>提升丢失恢复<ul>
<li>基于超时的重传次数减少了10倍以上，可以改善尾部延迟和YouTube视频回放率</li>
</ul>
</li>
<li>其他更小的改进<ul>
<li>例如，避免队头阻塞，更高效的分帧</li>
</ul>
</li>
</ul>
<h5 id="改进的拥塞控制"><a href="#改进的拥塞控制" class="headerlink" title="改进的拥塞控制"></a>改进的拥塞控制</h5><p>目前的 QUIC 的拥塞控制重新实现了一遍 TCP 的算法，毕竟 TCP 的算法是经过几十年的生产验证的，包括 TCP 的慢启动，拥塞避免，快重传，快恢复。在这些拥塞控制算法的基础上，再进行改进。</p>
<ul>
<li><p><strong>灵活性</strong>，不在内核层，可以随意更改，目前谷歌提供了两套算法（Cubic和NewReno）以供选择，并提供了一套很灵活友好的接口，让你去实验新的拥塞控制算法，而且还可以为不同应用设定不同的拥塞控制策略。</p>
</li>
<li><p><strong>提供更为详细的信息</strong>，如单调包序号，SACK</p>
</li>
<li><p><strong>尽可能避免超时重传</strong>，为了尽可能的实现快重传而不是超时重传，QUIC采用了Tail Loss Probes (TLPs)实现某些情况下的快重传机制触发。</p>
</li>
</ul>
<p>单调递增的 Packet Number。TCP 使用了基于字节序号 Sequence Number 和 ACK 来保证消息的有序到达。但是 Sequence Number 在重传的时候有二义性。你不知道下一个 ACK 是上一次请求的响应还是这次重传的响应。而单调递增的 Packet Number 可以避免这个问题，保证采样 RTT 的准确。</p>
<p>为了避免AIMD机制带来的带宽利用率低，采用了packet pacing来探测网络带宽。思路是，QUIC会通过追踪包的到达时间来预测当前带宽的使用情况，以决定是否提高，保持或者减少发送包的速率来避免网络拥塞。</p>
<p><img src="/images/packet_pacing.png" alt="packet_pacing"></p>
<p>QUIC ACK帧支持256个ACK块，相比TCP的SACK在TCP选项中实现，有长度限制，最多只支持3个ACK块</p>
<p>QUIC ACK包同时携带了从收到包到回复ACK的延时，这样结合递增的包序号，能够精确的计算RTT。</p>
<p>TLP算法如下图，服务器的segments 6-10丢失，客户端在等待s6时，由于没有收到后续的序列，因此无法触发快速重传机制，时间达到probe阈值（PTO）后，TLP算法对segments10进行重传，客户端收到这个重传序列，就能触发快速重传机制。而QUIC会在PTO之前就发送两个TLPs来尽可能避免等到超时再重传。</p>
<p><img src="F:%5Cweekly/images%5CTLP.png" alt="TLP"></p>
<h5 id="避免队头阻塞的多路复用"><a href="#避免队头阻塞的多路复用" class="headerlink" title="避免队头阻塞的多路复用"></a>避免队头阻塞的多路复用</h5><p>SPDY 和 HTTP/2 已经实现了<strong>多路复用</strong>。多路复用的指的是我们不需要在为每个资源重新建立一次 TCP 连接，多个资源的传输可以共用一个连接。</p>
<p><img src="/images/http2-multiplex.png" alt="多路复用"></p>
<p>如此一来，在启用了 HTTP/2 的网站，我们再也不需要对资源进行合并了（：）压缩还是可以做一下的），毕竟一次性发出去多个资源和建立多个连接一个一个下载资源相比还是会快一下的。</p>
<p>然后 HTTP/2 的多路复用会有个很大的问题，那就是<strong>队头阻塞</strong>。原因还是因为 TCP 的 Sequence Number 机制，为了保证资源的有序到达，如果传输队列的队头某个资源丢失了，TCP 必须等到这个资源重传成功之后才会通知应用层处理后续资源。</p>
<p><img src="/images/http2-multiplex-head-line-block.png" alt="多路复用"></p>
<p>由于 QUIC 避开了 TCP， 他设计 connection 和 stream 的概念，一个 connection 可以复用传输多个 stream，每个 stream 之间都是独立的，单一一个 stream 丢包并不会影响到其他资源处理。</p>
<p><img src="/images/quic-multiplex.png" alt="多路复用"></p>
<h5 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h5><p>TCP 是按照 4-要素（客户端IP、端口, 服务器IP、端口） 要确定一个连接的，当这4个要素其中一个发生变化的时候，连接就需要重新建立。而在移动端，我们经常会切换 4G/wifi 使用，每一次切换，我们只能重新建立连接。</p>
<p>在 QUIC 中，连接是由其维护的。 于是 QUIC 通过生成客户端生成一个 Connection ID （64位）的东西来区别不同连接，只要生成的 UUID 不变， 连接就不需要重新建立，即便是客户端的网络发生变化。</p>
<p><img src="/images/quic-header.png" alt="多路复用"></p>
<h5 id="前向冗余纠错"><a href="#前向冗余纠错" class="headerlink" title="前向冗余纠错"></a>前向冗余纠错</h5><p>这里的错误指的是某个包丢了。当某个 packet 丢失的时候，QUIC 能够通过已经接收到的其他包对资源进行修复。</p>
<p>这意味着，实际上每个 packet 都携带着多余的信息，通过这些信息，QUIC 能够重组对应资源，而无需进行重传。</p>
<p>目前大概每 10 个包能修复一个 packet。</p>
<h5 id="总是加密"><a href="#总是加密" class="headerlink" title="总是加密"></a>总是加密</h5><p>QUIC加密协议是QUIC的一部分，它为连接提供了传输安全性。QUIC加密协议是 注定要消亡的。未来它将由TLS 1.3替代，但在TLS 1.3 最终启用之前QUIC需要一个加密协议。</p>
<p>借助于当前的QUIC加密协议，当客户端已经缓存了关于服务器的信息时，它可以无需往返就建立一个加密的连接。TLS，相反地，至少需要两次往返（算上TCP的3次握手）。QUIC握手应该比普通的TLS 握手（2048-bit RSA）高效大约5倍，而且安全等级更高。</p>
<ul>
<li><p>源地址欺骗</p>
</li>
<li><p>重放攻击</p>
</li>
<li><p>握手开销小</p>
</li>
</ul>
<p>握手协议如下图</p>
<p><img src="/images%5Cquic-handshake-flow.png" alt="quic-handshake-flow"></p>
<h4 id="双级别流量控制"><a href="#双级别流量控制" class="headerlink" title="双级别流量控制"></a><strong>双级别流量控制</strong></h4><p>QUIC是多路复用的，多条stream可以建立在一条connection上，所以QUIC的流量控制不仅基于单个stream，还基于connection。<br>stream级别的流控能够控制单stream的数据发送情况。另外，接收窗口的收缩取决于最大接收字节的偏移而不是所有已接受字节的总和，它不像tcp流控，不会受到丢失数据的影响。</p>
<p><img src="/images%5Cstream_flow.png" alt="stream_flow"></p>
<p>如果满足(flow control receive offset - consumed bytes) &lt; (max receive window / 2)会触发WINDOW_UPDATE frame的发送来增大发送窗口大小。</p>
<p><img src="/images%5Cwindow_update_be.png" alt="window_update_be"></p>
<p><img src="/images%5Cwindow_update_af.png" alt="window_update_af"></p>
<p>connection级别流控算法和stream一致，各项数值是所有stream的总和。<br>connection级别的流控存在的必要是，即使做好了stream流控，但如果stream过多也会导致connection过度消耗带宽和系统资源；而且即使某一条stream过慢，其他stream依然能触发</p>
<p>connection级别的WINDOW_UPDATE，从而不会被影响。</p>
<p><img src="/images%5Cconnection_flow.png" alt="Connection"></p>
<h3 id="实现QUIC"><a href="#实现QUIC" class="headerlink" title="实现QUIC"></a>实现QUIC</h3><p><img src="/images%5C100_3.png" alt="chrome"></p>
<p>要想在浏览器上实现 QUIC ，有一些前置条件。由于现在好像只有 chrome 浏览器支持 QUIC 协议，所以下面的条件是针对 chrome 浏览器的。</p>
<p>整个 QUIC 协议比较复杂，想自己完全实现一套对笔者来说还比较困难。所以先看看开源实现有哪些：</p>
<h4 id="1-Chromium"><a href="#1-Chromium" class="headerlink" title="1. Chromium"></a>1. Chromium</h4><p>这个是官方支持的。优点自然很多，Google 官方维护基本没有坑，随时可以跟随 chrome 更新到最新版本。不过编译 Chromium 比较麻烦，它有单独的一套编译工具。暂时不考虑这个方案。</p>
<h4 id="2-proto-quic"><a href="#2-proto-quic" class="headerlink" title="2. proto-quic"></a>2. proto-quic</h4><p>从 chromium 剥离的一个 QUIC 协议部分，但是其 github 主页已宣布不再支持，仅作实验使用。不考虑这个方案。</p>
<h4 id="3-goquic"><a href="#3-goquic" class="headerlink" title="3. goquic"></a>3. goquic</h4><p>goquic 封装了 libquic 的 go 语言封装，而 libquic 也是从 chromium 剥离的，好几年不维护了，仅支持到 quic-36， goquic 提供一个反向代理，测试发现由于 QUIC 版本太低，最新 chrome 浏览器已无法支持。不考虑这个方案。</p>
<h4 id="4-quic-go"><a href="#4-quic-go" class="headerlink" title="4. quic-go"></a>4. quic-go</h4><p>quic-go 是完全用 go 写的 QUIC 协议栈，开发很活跃，已在 Caddy 中使用，MIT 许可，目前看是比较好的方案。</p>
<p>这里我做了两个测试：</p>
<ul>
<li>一个是基于proto-quic所做的正反代理，具体部署参考<a href="https://www.chromium.org/quic/playing-with-quic" target="_blank" rel="noopener">quic_toy</a></li>
<li>采用 caddy 来部署实现 QUIC</li>
</ul>
<p><img src="/images%5C100_7.png" alt="request"></p>
<p>部署方案如下：</p>
<p>nginx 还是继续使用，不过 nginx 只用来响应 TCP/443 端口，UDP/443 交给 caddy 来响应。nginx 返回响应头告诉 chrome 浏览器支持 QUIC，然后 caddy 作为反向代理 proxy 来转发。</p>
<p>但是caddy不支持关闭TCP端口，需要更改caddy的源码，关闭TCP:443端口，与nginx共存，让浏览器支持quic协议通信。</p>
<p>chrome版本必须 62-65 之间，如果高于这个版本或者低于这个版本，都会导致 QUIC 握手失败，进而无法进行 QUIC 通讯。</p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><h5 id="2017年海外部署测试"><a href="#2017年海外部署测试" class="headerlink" title="2017年海外部署测试"></a>2017年海外部署测试</h5><p>QUIC还处于实验性阶段，但是已经在chrome等大多浏览器，腾讯云，部分服务站点得到支持。</p>
<p>为了测试quic在国外外网环境差的情况下的表现，设计正反代理，代理之间走quic协议，这种方式测试quic的表现，如下所示，架构图。</p>
<p><img src="/images%5Ccanada.png" alt="canada"></p>
<p>其中quic proxy是通过官网提供的proto_quic的c++源码，加上自身的proxy解析协议实现的，具体demo可以参考视频。</p>
<p>测试过程是通过Q调进行的，具体的数据如下：</p>
<p><img src="/images%5Cquic_conn.png" alt="quic"></p>
<p><img src="/images%5Cdirect_conn.png" alt="direct"></p>
<p>可以看出其中经过quic加速后速度确实有提升，正如官方宣称的那样。</p>
<p>香港proxy端是接入的<strong>天天P图</strong>的业务，经测试是正常的。</p>
<h5 id="QQ页面接入测试"><a href="#QQ页面接入测试" class="headerlink" title="QQ页面接入测试"></a>QQ页面接入测试</h5><p>QQ会员团队通过灰度现网的一个页面来考察QUIC在现网的性能情况。</p>
<ul>
<li><p>页面情况<br>Android日PV100w，页面大小95KB<br>总请求30个，其中主资源请求1个，CDN请求24个，其他请求5个<br>展示部分依赖php直出和js渲染</p>
</li>
<li><p>灰度情况<br>QUIC请求1个（php页面主资源），HTTP2请求29个</p>
</li>
<li><p>灰度策略 </p>
</li>
</ul>
<p>客户端每天放量，对比灰度过程中页面主资源的HTTP2和QUIC的性能数据</p>
<ul>
<li>灰度效果</li>
</ul>
<p><img src="/images/qqhuiyuan.png" alt="qq test"></p>
<ul>
<li><p>效果说明</p>
<p>因为建连依赖于1RTT和0RTT机制，使得QUIC建连平均耗时仅需46ms，比HTTP2的225ms减少180ms左右。</p>
<p>由于目前灰度量只占到总请求量的10%，因此更严谨的性能对比数据有待进一步提高灰度范围，以上仅作现阶段参考。</p>
<p>但依然可以看到QUIC在现网环境总体表现忧于HTTP2。</p>
</li>
</ul>
<p>quic在弱网中的表现如下：</p>
<p><img src="F:%5Cweekly/images%5Cquic_test.png" alt="quic_test"></p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="性能优化1：提升-0RTT-成功率"><a href="#性能优化1：提升-0RTT-成功率" class="headerlink" title="性能优化1：提升 0RTT 成功率"></a>性能优化1：提升 0RTT 成功率</h4><p>安全传输层虽然能够实现 0RTT，优势非常明显。但问题是，不是每一次连接都能实现 0RTT，对于我们的客户端和服务端来讲，如何最大程度地提升 0RTT 的成功率？</p>
<p>0RTT 能实现的关键是 ServerConfig。就像 TLS session resume 实现的关键是 session id 或者 session ticket 一样。ServerConfig 到达服务端后，我们根据 ServerConfig ID 查找本地内存，如果找到了，即认为这个数据是可信的，能够完成 0RTT 握手。</p>
<h4 id="性能优化2：连接迁移-Connection-Migration-的实现"><a href="#性能优化2：连接迁移-Connection-Migration-的实现" class="headerlink" title="性能优化2：连接迁移 (Connection Migration) 的实现"></a>性能优化2：连接迁移 (Connection Migration) 的实现</h4><p>那  服务端如何实现的呢？我们在 CLB 四层转发层面实现了根据 ID 进行哈希的负载均衡算法，保证将相同 ID 的 QUIC 请求落到相同的 CLB7 层集群上，在 CLB7 上，我们又会优先根据 ID 进行处理。</p>
<p>同一台 CLB7 保存了相同的 Stream 及 Connection 处理上下文，能够将该请求继续调度到相同的业务 RS 机器。</p>
<p>整个网络和 IP 切换过程，对于用户和业务来讲，没有任何感知。</p>
<h4 id="性能优化3：动态的流量控制和拥塞控制"><a href="#性能优化3：动态的流量控制和拥塞控制" class="headerlink" title="性能优化3：动态的流量控制和拥塞控制"></a>性能优化3：动态的流量控制和拥塞控制</h4><p>在连接和 Stream 级别设置了不同的窗口数。</p>
<p>最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。</p>
<h3 id="包类型和格式"><a href="#包类型和格式" class="headerlink" title="包类型和格式"></a>包类型和格式</h3><p>QUIC 具有特殊包和普通包。有两种类型特殊包：版本协商包 (Version Negotiation Packets) 和 公共复位包 (Public Reset Packets)，普通包包含帧。</p>
<p>所有 QUIC 包的大小应该适配在路径的 MTU 以避免IP分片。路径 MTU 发现是正在进行中的工作，而当前 QUIC 实现为 IPv6 使用 1350 字节的最大QUIC包大小，IPv4 使用1370字节。两个大小都没有 IP 和 UDP 过载。</p>
<h4 id="QUIC公共包头"><a href="#QUIC公共包头" class="headerlink" title="QUIC公共包头"></a>QUIC公共包头</h4><p>传输的所有 QUIC 包以大小介于1至51字节的公共包头开始。公共包头的格式如下：</p>
<pre><code>--- src
     0        1        2        3        4            8
+--------+--------+--------+--------+--------+---    ---+
| Public |    Connection ID (64)    ...                 | -&gt;
|Flags(8)|      (optional)                              |
+--------+--------+--------+--------+--------+---    ---+
     9       10       11        12   
+--------+--------+--------+--------+
|      QUIC Version (32)            | -&gt;
|         (optional)                |                           
+--------+--------+--------+--------+
    13       14       15        16      17       18       19       20
+--------+--------+--------+--------+--------+--------+--------+--------+
|                        Diversification Nonce                          | -&gt;
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+
    21       22       23        24      25       26       27       28
+--------+--------+--------+--------+--------+--------+--------+--------+
|                   Diversification Nonce Continued                     | -&gt;
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+
    29       30       31        32      33       34       35       36
+--------+--------+--------+--------+--------+--------+--------+--------+
|                   Diversification Nonce Continued                     | -&gt;
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+
    37       38       39        40      41       42       43       44
+--------+--------+--------+--------+--------+--------+--------+--------+
|                   Diversification Nonce Continued                     | -&gt;
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+
    45      46       47        48       49       50
+--------+--------+--------+--------+--------+--------+
|           Packet Number (8, 16, 32, or 48)          |
|                  (variable length)                  |
+--------+--------+--------+--------+--------+--------+</code></pre><p>公共头部中的字段如下：</p>
<ul>
<li><p><strong>公共标记（Public Flags）</strong></p>
<ul>
<li>0x01 = PUBLIC_FLAG_VERSION。这个标记的含义与包是由服务器还是客户端发送的有关。当由客户端发送时，设置它表示头部包含 QUIC 版本 (参考下面的说明)。客户端必须在所有的包中设置这个位，直到客户端收到来自服务器的确认，同意所提议的版本。服务器通过发送不设置该位的包来表示同意版本。当这个位由服务器设置时，包是版本协商包。版本协商在后面更详细地描述</li>
<li>0x02 = PUBLIC_FLAG_RESET。设置来表示包是公共复位包。</li>
<li>0x04 = 表明在头部中存在 32字节的多样化随机数。</li>
<li>0x08 = 表明包中存在完整的8字节连接ID。必须为所有包设置该位，直到为给定方向协商出不同的值 (比如，客户端可以请求包含更少字节的连接ID)。</li>
<li>0x30 处的两位表示每个包中存在的数据包编号的低位字节数。这些位只用于帧包。没有包号的公共复位和版本协商包 (由服务器发送) ，不使用这些位，且必须被设置为0。这2位的掩码：<ul>
<li>0x30 表示包号占用6个字节</li>
<li>0x20 表示包号占用4个字节</li>
<li>0x10 表示包号占用2个字节</li>
<li>0x00 表示包号占用1个字节</li>
</ul>
</li>
<li>0x40 为多路径使用保留。</li>
<li>0x80 当前未使用，且必须被设置为0。</li>
</ul>
</li>
<li><p><strong>连接ID</strong>：这是客户端选择的无符号64位统计随机数，该数字是连接的标识符。由于 QUIC 的连接被设计为，即使客户端漫游，连接依然保持建立状态，因而 IP 4元组（源IP，源端口，目标IP，目标端口）可能不足以标识连接。对每个传输方向，当4元组足以标识连接时，连接ID可以省略。</p>
</li>
<li><p><strong>QUIC版本</strong>：表示 QUIC 协议版本的32位不透明标记。只有在公共标记包含 FLAG_VERSION（比如 public_flags &amp; FLAG_VERSION !=0） 时才存在。客户端可以设置这个标记，并 准确 包含一个提议版本，同时包含任意的数据（与该版本一致）。当客户端提议的版本不支持时，服务器可以设置这个标记，并可以提供一个可接受版本的列表（0或多个），但 一定不能(MUST not) 在版本信息之后包含任何数据。</p>
</li>
<li><p><strong>包号</strong>(Packet Number)：包号的低 8，16，32，或 48 位，基于公共标记的FLAG_BYTE_SEQUENCE_NUMBER 标记。每个普通包（与特别的公共复位和版本协商包相反）由发送者分配包号。由某一端发送的首包包号应该为1，后续每个包的包号应该比前一个的大1。包号的低64位被用作加密随机数的一部分；然而，QUIC 端点一定不能发送其包号无法以 64 位表示的包。如果 QUIC 端点传输了包号为 (2^64-1) 的包，则该包必须包含错误码为 QUIC_SEQUENCE_NUMBER_LIMIT_REACHED 的 CONNECTION_CLOSE 帧，且对端一定不能再传输任何其它包。</p>
</li>
</ul>
<p>公共标记处理流程：</p>
<pre><code>--- src
Check the public flags in public header
                 |
                 |
                 V
           +--------------+
           | Public Reset |    YES
           | flag set?    |---------------&gt; Public Reset Packet
           +--------------+
                 |
                 | NO
                 V
           +------------+          +-------------+
           | Version    |   YES    | Packet sent |  YES
           | flag set?  |---------&gt;| by server?  |--------&gt; Version Negotiation
           +------------+          +-------------+               Packet
                 |                        |
                 | NO                     | NO
                 V                        V
           Regular Packet         Regular Packet with
                               QUIC Version present in header
---</code></pre><h4 id="特殊包"><a href="#特殊包" class="headerlink" title="特殊包"></a>特殊包</h4><h5 id="版本协商包"><a href="#版本协商包" class="headerlink" title="版本协商包"></a>版本协商包</h5><p>只有服务器会发送版本协商包。版本协商包以8位的公共标记和64位的连接ID开始。公共标记必须设置PUBLIC_FLAG_VERSION，并指明64位的连接ID。版本协商包的其余部分是服务器支持的版本的4字节列表：</p>
<pre><code>--- src
     0        1        2        3        4        5        6        7       8
+--------+--------+--------+--------+--------+--------+--------+--------+--------+
| Public |    Connection ID (64)                                                 | -&gt;
|Flags(8)|                                                                       |
+--------+--------+--------+--------+--------+--------+--------+--------+--------+
     9       10       11        12       13      14       15       16       17
+--------+--------+--------+--------+--------+--------+--------+--------+---...--+
|      1st QUIC version supported   |     2nd QUIC version supported    |   ...
|      by server (32)               |     by server (32)                |             
+--------+--------+--------+--------+--------+--------+--------+--------+---...--+
</code></pre><h5 id="公共复位包"><a href="#公共复位包" class="headerlink" title="公共复位包"></a>公共复位包</h5><p>公共复位包以8位的公共标记和64位的连接ID开始。公共标记必须设置 PUBLIC_FLAG_RESET，并表明64位的连接ID。公共复位包的其余部分像标记 PRST 的加密握手消息那样编码</p>
<pre><code>--- src
     0        1        2        3        4         8
+--------+--------+--------+--------+--------+--   --+
| Public |    Connection ID (64)                ...  | -&gt;
|Flags(8)|                                           |
+--------+--------+--------+--------+--------+--   --+
     9       10       11        12       13      14       
+--------+--------+--------+--------+--------+--------+---
|      Quic Tag (32)                |  Tag value map      ... -&gt;
|         (PRST)                    |  (variable length)                         
+--------+--------+--------+--------+--------+--------+---</code></pre><p><strong>标记值映射</strong>：标记值映射包含如下的标记值：</p>
<ul>
<li>RNON (public reset nonce proof) - 一个64位的无符号整数</li>
<li>RSEQ (rejected packet number) - 一个64位的包号</li>
<li>CADR (client address) - 观察到的客户端IP地址和端口号。它当前只被用于调试，因而是可选的</li>
</ul>
<h4 id="普通包"><a href="#普通包" class="headerlink" title="普通包"></a>普通包</h4><p>普通包已经过认证和加密。公共头部已认证但未加密，从第一帧开始的包的其余部分已加密。紧随公共头部之后，普通包包含 AEAD（authenticated encryption and associated data）数据。要解释内容，这些数据必须先解密。解密之后，明文由一系列帧组成。</p>
<h5 id="帧包"><a href="#帧包" class="headerlink" title="帧包"></a>帧包</h5><p>帧包具有一个载荷，它是一系列的类型前缀帧。帧类型的格式将在本文档的后面定义，但帧包的通用格式如下：</p>
<pre><code>--- src
+--------+---...---+--------+---...---+
| Type   | Payload | Type   | Payload |
+--------+---...---+--------+---...---</code></pre><h3 id="QUIC连接生命周期"><a href="#QUIC连接生命周期" class="headerlink" title="QUIC连接生命周期"></a>QUIC连接生命周期</h3><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><p>QUIC 客户端是初始化连接的端点。QUIC 的连接建立将版本协商与加密和传输握手交织在一起以减少连接建立延迟。</p>
<p>最初由客户端发向服务器的每个包必须设置版本标记，而且必须指定使用的协议版本。客户端发送的每个包必须开启版本标记，直到它从服务器收到了版本标记关闭的包。在服务器从客户端收到了第一个版本标记关闭的包后，它必须忽略（可能由于延迟）任何版本标记打开的包。</p>
<p>当服务器收到一个含有新连接连接ID的包时，它将对比客户端的版本和它支持的版本。如果客户端的版本对于服务器来说可以接受，服务器将在连接的整个生命周期中使用这个协议版本。在这种情况下，服务器发送的所有包的版本标记都是关闭的。</p>
<p>如果服务器不接受客户端的版本，则导致 1-RTT 的延迟。服务器将给客户端发送一个版本协商包。该包将设置版本标记，并包含服务器支持版本的集合。</p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>QUIC 实现了连接可靠性，拥塞控制，和流控。QUIC 流控紧随 HTTP/2 的流控之后。QUIC 可靠性和拥塞控制在一份附带文档中描述。QUIC 连接使用一个单独的包序列号空间，以此跨连接共享拥塞控制和丢失恢复。</p>
<p>QUIC 连接中传输的所有数据，包括加密握手，被作为流内数据发送，但ACKs 确认 QUIC 包。</p>
<h4 id="QUIC流的生命"><a href="#QUIC流的生命" class="headerlink" title="QUIC流的生命"></a>QUIC流的生命</h4><p>流是被分割为流帧的双向数据的独立序列。流可以由客户端或服务器创建，可以与其它流并发交错地发送数据，且可以取消。</p>
<p>流创建通过为给定的流发送一个 STREAM 帧显式地完成。为了避免流 ID 冲突，如果流由服务器初始化，则流 ID 必须是偶数，而如果由客户端初始化则必须为奇数。0 不是一个有效的流 ID。流 1 为加密握手保留，它应该是第一个客户端初始化的流。当基于 QUIC 使用 HTTP/2 时，流 3 为传输所有其它流的压缩首部而保留，以确保首部的处理和传送可靠且有序。</p>
<h4 id="帧类型和格式"><a href="#帧类型和格式" class="headerlink" title="帧类型和格式"></a>帧类型和格式</h4><p>帧类型字节有两种解释，产生两种帧类型：特殊帧类型，和常规帧类型。特殊帧类型在帧类型字节中编码帧类型和对应的标志，而常规帧类型简单地使用帧类型字节。</p>
<p>当前定义的特殊帧类型如下：</p>
<pre><code>--- src
   +------------------+-----------------------------+
   | Type-field value |     Control Frame-type      |
   +------------------+-----------------------------+
   |     1fdooossB    |  STREAM                     |
   |     01ntllmmB    |  ACK                        |
   |     001xxxxxB    |  CONGESTION_FEEDBACK        |
   +------------------+-----------------------------+
---</code></pre><p>当前定义的常规帧类型如下：</p>
<pre><code>--- src
   +------------------+-----------------------------+
   | Type-field value |     Control Frame-type      |
   +------------------+-----------------------------+
   | 00000000B (0x00) |  PADDING                    |
   | 00000001B (0x01) |  RST_STREAM                 |
   | 00000010B (0x02) |  CONNECTION_CLOSE           |
   | 00000011B (0x03) |  GOAWAY                     |
   | 00000100B (0x04) |  WINDOW_UPDATE              |
   | 00000101B (0x05) |  BLOCKED                    |
   | 00000110B (0x06) |  STOP_WAITING               |
   | 00000111B (0x07) |  PING                       |
   +------------------+-----------------------------+
---</code></pre><h5 id="STREAM帧"><a href="#STREAM帧" class="headerlink" title="STREAM帧"></a>STREAM帧</h5><p>STREAM 帧同时被用于隐式地创建流和在流上发送数据，其格式如下：</p>
<pre><code>--- src
     0        1       …               SLEN
+--------+--------+--------+--------+--------+
|Type (8)| Stream ID (8, 16, 24, or 32 bits) |
|        |    (Variable length SLEN bytes)   |
+--------+--------+--------+--------+--------+
  SLEN+1  SLEN+2     …                                         SLEN+OLEN   
+--------+--------+--------+--------+--------+--------+--------+--------+
|   Offset (0, 16, 24, 32, 40, 48, 56, or 64 bits) (variable length)    |
|                    (Variable length: OLEN  bytes)                     |
+--------+--------+--------+--------+--------+--------+--------+--------+
  SLEN+OLEN+1   SLEN+OLEN+2
+-------------+-------------+
| Data length (0 or 16 bits)|
|  Optional(maybe 0 bytes)  |
+------------+--------------+
---</code></pre><p>STREAM 帧首部中的字段如下：</p>
<ul>
<li><strong>帧类型：</strong> 帧类型字节是一个包含多种标记 (1fdooossB) 的 8 位值：<ul>
<li>最左边的位必须被设为 1 以表明这是一个 STREAM 帧。</li>
<li>‘f’ 位是FIN位。当被设置为 1 时，这个位表明发送者已经完成在流上的发送并希望 “half-close（半关闭）”</li>
<li>‘d’ 位表明 STREAM 头部中是否包含数据长度。当设为 0 时，这个字段表明 STREAM 帧扩展至数据包的结尾处。</li>
<li>接下来的三个 ‘ooo’ 位编码 Offset 头部字段的长度为 0，16，24，32，40，48，56，或 64 位长。</li>
<li>接下来的两个 ‘ss’ 位编码流 ID 头部字段的长度为 8，16，24，或 32 位长。</li>
</ul>
</li>
<li><strong>流 ID：</strong> 一个大小可变的流唯一的无符号ID</li>
<li><strong>偏移：</strong> 一个大小可变的无符号数字描述流中这块数据的字节偏移</li>
<li><strong>数据长度：</strong> 一个可选的 16 位无符号数字描述这个流帧中数据的长度。只有当包是 “全大小(full-sized)” 包时，才应该省略长度，以避免通过填充发生腐败的风险</li>
</ul>
<p>流帧必须总是具有非零数据长度，或设置 FIN 位。</p>
<h5 id="ACK帧"><a href="#ACK帧" class="headerlink" title="ACK帧"></a>ACK帧</h5><p>发送 ACK 帧以通知对端哪些包已经收到，以及接收者仍然认为哪些包丢失了（丢失包的内容可能需要被重发）。ACK 帧包含 1 到 256 个 ack 块。Ack 块是确认的包的范围，与 TCP 的 SACK 块类似，但 QUIC 没有 TCP 的累积ack 点的等价物，因为包将以新的序列号重传。</p>
<p>不像TCP SACK，QUIC ACK块是不可变的，因此一旦一个包被确认了，即使它没有出现在未来的ack帧中，它也被假设已经确认。</p>
<h6 id="段偏移"><a href="#段偏移" class="headerlink" title="段偏移"></a>段偏移</h6><p>0：Ack帧的起始位置。</p>
<p>T：时间戳段起始位置的字节偏移量。</p>
<p>A：Ack块段起始位置的字节偏移量。</p>
<p>N：最大已确认的字节长度。</p>
<pre><code>--- src
     0                            1  =&gt; N                     N+1 =&gt; A(aka N + 3)
+---------+-------------------------------------------------+--------+--------+
|   Type  |                   Largest Acked                 |  Largest Acked  |
|   (8)   |    (8, 16, 32, or 48 bits, determined by ll)    | Delta Time (16) |
|01nullmm |                                                 |                 |
+---------+-------------------------------------------------+--------+--------+
     A             A + 1  ==&gt;  A + N
+--------+----------------------------------------+              
| Number |             First Ack                  |
|Blocks-1|           Block Length                 |
| (opt)  |(8, 16, 32 or 48 bits, determined by mm)|
+--------+----------------------------------------+
  A + N + 1                A + N + 2  ==&gt;  T(aka A + 2N + 1)
+------------+-------------------------------------------------+
| Gap to next|              Ack Block Length                   |
| Block (8)  |   (8, 16, 32, or 48 bits, determined by mm)     |
| (Repeats)  |       (repeats Number Ranges times)             |
+------------+-------------------------------------------------+
     T        T+1             T+2                 (Repeated Num Timestamps)
+----------+--------+---------------------+ ...  --------+------------------+  
|   Num    | Delta  |     Time Since      |     | Delta  |       Time       |
|Timestamps|Largest |    Largest Acked    |     |Largest |  Since Previous  |
|   (8)    | Acked  |      (32 bits)      |     | Acked  |Timestamp(16 bits)|
+----------+--------+---------------------+     +--------+------------------+
---</code></pre><p>ACK 帧中的字段如下：</p>
<ul>
<li><strong>帧类型：</strong> 帧类型字节是一个包含多种标记（01nullmmB）的 8 位值<ul>
<li>开始的两位必须被设置为 01，以表明这是一个 ACK 帧</li>
<li>‘n’ 位表明帧是否有多于 1 个的 Ack 范围</li>
<li>‘u’ 位尚未使用</li>
<li>两个 ‘ll’ 位编码最大已观察字段的长度为 1，2，4，或者 6 字节长</li>
<li>两个 ‘mm’ 位编码丢失包序列号差值字段的长度为 1，2，4，或者 6 字节长</li>
</ul>
</li>
<li><strong>最大已确认(Largest Acked)：</strong> 一个大小可变的无符号值，表示对端已观察到的最大包号</li>
<li><strong>最大已确认差值时间(Largest Acked Delta Time)：</strong> 一个 16 位无符号浮点数，其中 11 个显式位为底数，5 位的显式指数，描述自收到最大已确认包至这个 Ack 帧发送之间经过的微秒数</li>
<li><strong>Ack 块段 (Ack Block Section)：</strong><ul>
<li><strong>块个数 (Num Blocks)</strong> ：一个可选的8位无符号值描述 ack 块的个数减一。只有在 ‘n’ 标记位为 1 时才存在</li>
<li><strong>Ack块长度 (Ack block length)</strong> ：一个大小可变的包号差值。对于第一个丢失包范围，Ack 块以最大已确认包开始。对于首个 Ack 块，Ack 块的长度为 1 + 该值。对于后续的 Ack 块，它是 Ack 块的长度。对于非首个块，0值表示多于 256 个包丢失了</li>
<li><strong>到下一块的间隙 (Gap to next block)</strong> ：一个8位无符号值，描述 Ack 块之间的包个数</li>
</ul>
</li>
<li><strong>时间戳段 (Timestamp Section)：</strong><ul>
<li><strong>时间戳个数 (Num Timestamp)</strong> ：一个 8 位无符号值描述包含在这个 Ack 帧中的时间戳个数。在后面的 timestamps 中将有许多 &lt;packet number, timestamp&gt; 对。</li>
<li><strong>已观察最大差值 (Delta Largest Observed)</strong> ：一个8位无符号值描述首个时间戳和最大已观察包之间包号的差值。然而，包号为最大已观察包号 减去 已观察最大差值 (delta largest observed)。</li>
<li><strong>首个时间戳 (First Timestamp)</strong> ：一个32位无符号值，描述从最大观测值指定的数据包到达的连接开始减去最大观测差值的时间增量（以微秒为单位）。</li>
<li><strong>最大观察差值（重复）(Delta Largest Observed(Repeated))</strong> ：（同上。）</li>
<li><strong>自前一个时间戳的时间（重复） (Time Since Previous Timestamp (Repeated))</strong> ：一个 16 位无符号值描述与前一个时间戳的差值。它的编码格式与 Ack Delay Time 相同。</li>
</ul>
</li>
</ul>
<h5 id="STOP-WAITING-帧"><a href="#STOP-WAITING-帧" class="headerlink" title="STOP_WAITING 帧"></a>STOP_WAITING 帧</h5><p>STOP_WAITING 帧用于通知对端，它不应该继续等待包号小于特定值的包。包号以1，2，4或6字节编码，using the same coding length as is specified for the packet number for the enclosing packet’s header (specified in the QUIC Frame Packet’s Public Flags field.) 这个帧如下:</p>
<pre><code>--- src
     0        1        2        3         4       5       6  
+--------+--------+--------+--------+--------+-------+-------+
|Type (8)|   Least unacked delta (8, 16, 32, or 48 bits)     |
|        |                       (variable length)           |
+--------+--------+--------+--------+--------+--------+------+
---</code></pre><p>STOP_WAITING帧中的字段如下：</p>
<ul>
<li><strong>帧类型：</strong>帧类型是一个8位的值，它必须被设置为0x06以表明这是一个STOP_WAITING帧</li>
<li><strong>最小未确认差值：</strong>一个可变长度的包号差值，与包首部的包号长度相同。将它从头部的包号减去以确定最小的未确认包。结果的最小未确认包是发送者依然在等待确认的包号最小的包。如果接收者丢失了任何比这个值小的包，接收者应该将那些包认做无可挽回的丢失</li>
</ul>
<h5 id="WINDOW-UPDATE-帧"><a href="#WINDOW-UPDATE-帧" class="headerlink" title="WINDOW_UPDATE 帧"></a>WINDOW_UPDATE 帧</h5><p>WINDOW_UPDATE 帧用于通知对端一个端点的流量控制接收窗口的增长。流ID可以是0，表示WINDOW_UPDATE应用于连接级的流量控制窗口，或者 &gt; 0 表示指定的流应该增长它的流量控制窗口。帧如下：</p>
<pre><code>--- src
    0         1                 4        5                 12
+--------+--------+-- ... --+-------+--------+-- ... --+-------+
|Type(8) |    Stream ID (32 bits)   |  Byte offset (64 bits)   | 
+--------+--------+-- ... --+-------+--------+-- ... --+-------+
---</code></pre><p>WINDOW_UPDATE帧中的字段如下：</p>
<ul>
<li><strong>帧类型：</strong>帧类型是一个8位值，它必须被设置为0x04以表示这是一个WINDOW_UPDATE帧。</li>
<li><strong>流 ID：</strong>要更新流控制窗口的流的ID，或者为0来描述连接级的流控制窗口。</li>
<li><strong>字节偏移：</strong> 一个64位无符号整型值，表示在给定的流上可以发送的数据的完整字节偏移量。在连接级流量控制的情况下，是在当前所有打开的流上可以发送的字节的总和。</li>
</ul>
<h5 id="BLOCKED-帧"><a href="#BLOCKED-帧" class="headerlink" title="BLOCKED 帧"></a>BLOCKED 帧</h5><p>BLOCKED帧用于向远端指明本端点已经准备好发送数据了（且有数据要发送），但是当前被流量控制阻塞了。这是一个纯粹的信息帧，它对于调试极其有用。BLOCKED帧的接收者应该简单的丢弃它（可能在打印了一条有帮助的log消息之后）。帧如下：</p>
<pre><code>--- src
     0        1        2        3         4
+--------+--------+--------+--------+--------+
|Type(8) |          Stream ID (32 bits)      |  
+--------+--------+--------+--------+--------+
---</code></pre><p>BLOCKED帧中的字段如下：</p>
<ul>
<li><strong>帧类型</strong>：帧类型是一个8位值，它必须被设置为0x05以表示这是一个BLOCKED帧。</li>
<li><strong>流 ID</strong>：一个32位的无符号数，表示流量控制阻塞的流。非零 流 ID 字段描述了被流量控制阻塞的流。当这个值为0时，流 ID字段在连接级指明连接被流量控制阻塞了。</li>
</ul>
<h5 id="RST-STREAM-帧"><a href="#RST-STREAM-帧" class="headerlink" title="RST_STREAM 帧"></a>RST_STREAM 帧</h5><p>RST_STREAM帧允许异常终止一条流。当这个帧是流的创建者发出的，表示创建者希望取消这条流。当接收端发送这个帧，表示有错误或者当前接收端不希望接收这个流，因此这个流应该被关闭。帧结构如下：</p>
<pre><code>--- src
     0        1            4      5              12     8             16
+-------+--------+-- ... ----+--------+-- ... ------+-------+-- ... ------+
|Type(8)| StreamID (32 bits) | Byte offset (64 bits)| Error code (32 bits)|
+-------+--------+-- ... ----+--------+-- ... ------+-------+-- ... ------+
---</code></pre><p>RST_STREAM帧的字段如下:</p>
<ul>
<li><strong>帧类型</strong>: 帧类型是一个8位的值，必须设置为0x01表示这是一个RST_STREAM帧。</li>
<li><strong>流标识符</strong>: 32位流标识符，表示将被终止的流。</li>
<li><strong>字节偏移</strong>: 64位无符号整型表示流数据的绝对字节偏移。</li>
<li><strong>错误码</strong>: 32位的QUIC错误码表示流被关闭的原因，错误码在文档后续列出。</li>
</ul>
<h5 id="CONNECTION-CLOSE-帧"><a href="#CONNECTION-CLOSE-帧" class="headerlink" title="CONNECTION_CLOSE 帧"></a>CONNECTION_CLOSE 帧</h5><p>CONNECTION_CLOSE帧用来通知连接将被关闭。如果流仍然有数据在发送，那么在连接关闭时，这些流将被隐式关闭。（理论上一个GOAWAY帧应该已经被发送了足够的时间使所有流都关闭。）帧结构如下：</p>
<pre><code>--- src
     0        1             4        5        6       7       
+--------+--------+-- ... -----+--------+--------+--------+----- ...
|Type(8) | Error code (32 bits)| Reason phrase   |  Reason phrase  
|        |                     | length (16 bits)|(variable length)
+--------+--------+-- ... -----+--------+--------+--------+----- ...
---</code></pre><p>CONNECTION_CLOSE帧的字段如下:</p>
<ul>
<li><strong>帧类型</strong>: 8位的值必须设置为0x02，表示这个帧是一个CONNECTION_CLOSE帧。</li>
<li><strong>错误码</strong>: 32位字段包含了QUIC错误码，表明连接关闭原因。</li>
<li><strong>原因描述长度</strong>: 16位无符号数，表示reason phrase的长度。如果发送方除了错误码之外，并不打算给出详细情况，那么该字段可能为0。</li>
<li><strong>原因描述</strong>: 可选的可读的连接关闭的原因。</li>
</ul>
<h3 id="QUIC现状"><a href="#QUIC现状" class="headerlink" title="QUIC现状"></a>QUIC现状</h3><p>HTTP-over-QUIC 将被吸收改名为 HTTP/3。未来的 web 传输不再依赖 TCP 协议，升级更新也不再需要依赖系统内核升级了，未来的 HTTP 可以跟其他产品一样月更、甚至周更。</p>
<p>目前，如果想体验 QUIC 可以使用 <a href="https://github.com/mholt/caddy/wiki/QUIC" target="_blank" rel="noopener">candy</a> 服务器。candy 在 0.9 版本之后就支持 QUIC 了。</p>
<p>在 github 上面找到了 <a href="https://github.com/devsisters/libquic" target="_blank" rel="noopener">C++ 版本</a>的实现，利用 Nodejs 的 C++ 模块，我们可以快速实现一个 node-quic 的样子。也可以实现自己的C++版本，或者在chrome中打开quic选项，体验quic加速的效果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>QUIC是一个实现在UDP上的可靠的、多路复用的协议，总是加密的，更少的连接延迟时间，FEC差错冗余，快速更新的用户空间级别实现，还是开源，将会成为HTTP/3，是以后网络发展的趋势。</p>
<p>据说，QUIC作为一个试验场，很多idear都会被平移到更加规范的标准中，比如BBR之于TCP(不过我是非常不看好TCP的，BBR在QUIC上持续持久发展难道不更好吗？)。同样这个0RTT的思路也将会被吸纳到在途的TLS1.3版本中，非常期待。</p>
<p>这一切非常感谢Google，一家伟大的公司。从看到HTTP的弊端到SPDY，然后再到HTTP2.0，进而又看到了TCP的弊端，因此从SPDY/HTTP2.0直接衍生出QUIC，子啊QUIC本身的进化过程中，对于TCP也是择其善者而从之，其不善者而改之，这就是我们现在接触到的QUIC协议，集HTTP2.0，TCP于大成的QUIC协议。</p>
<p>不管怎么说，我个人是比较看好QUIC的。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1522515386@qq.com </span>
    </div>
</article>


<p>
    <a href="javascript:void(0)" class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>QUIC协议介绍</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">9.7k</span></p>
    <p><span class="copy-title">本文作者:</span><a href="javascript:void(0)" title="Blitz">Blitz</a></p>
    <p><span class="copy-title">发布时间:</span>2019-10-26, 11:16:37</p>
    <p><span class="copy-title">最后更新:</span>2019-10-26, 17:25:41</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2019/10/26/QUIC%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/" title="QUIC协议介绍">http://yoursite.com/2019/10/26/QUIC%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>



    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '51f8cc487ebfe419b7c8',
            clientSecret: 'f0eb2fd84459591ad82953f3767c6b18ee26c98e',
            repo: 'WhatDream.github.io',
            owner: 'WhatDream',
            admin: ['WhatDream'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2019 Blitz</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" href="javascript:void(0)"></a>
    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢就点赞,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.png" class="alipay" title="扫码支持">
            <img src="/img/wxpay.png" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="weixin">微信</label></span><span><label><input type="radio" name="pay" value="alipay">支付宝</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#Idempotency','#mysql','#lock','#quic','#udp','#node','#spinlock',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
</style>







</html>
